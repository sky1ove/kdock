# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_gnina_AF3_rescore.ipynb.

# %% auto 0
__all__ = ['ChainSelect', 'rename_residues', 'split_cif', 'pdb2sdf', 'prepare_rec_lig', 'gnina_rescore_local',
           'gnina_rescore_docker', 'extract_gnina_rescore', 'get_gnina_rescore', 'get_gnina_rescore_folder']

# %% ../nbs/05_gnina_AF3_rescore.ipynb 3
import pandas as pd
import re, os, subprocess, py3Dmol
from Bio.PDB import MMCIFParser, PDBIO, Select
from rdkit import Chem
from rdkit.Chem import AllChem
from pathlib import Path
from fastcore.all import L
from tqdm.contrib.concurrent import process_map
from functools import partial

# %% ../nbs/05_gnina_AF3_rescore.ipynb 5
class ChainSelect(Select):
    "Select chain to save"
    def __init__(self, chain_ids):
        self.chain_ids = chain_ids
    def accept_chain(self, chain):
        return chain.get_id() in self.chain_ids

# %% ../nbs/05_gnina_AF3_rescore.ipynb 6
def rename_residues(structure, chain_id, new_resname='LIG'):
    "Rename residue name from LIG_L to LIG as LIG_L exceeds lengths and leads to error in RDKit"
    for model in structure:
        for chain in model:
            if chain.id == chain_id:
                for residue in chain:
                    residue.resname = new_resname

# %% ../nbs/05_gnina_AF3_rescore.ipynb 7
def split_cif(cif_path, chainA_pdb_path, chainL_pdb_path):
    "Split AF3 output CIF to protein and ligand PDBs"
    parser = MMCIFParser(QUIET=True)
    structure = parser.get_structure('complex', cif_path)
    rename_residues(structure, chain_id='L', new_resname='LIG')
    io = PDBIO()
    io.set_structure(structure)
    io.save(str(chainA_pdb_path), ChainSelect('A'))  # receptor
    io.save(str(chainL_pdb_path), ChainSelect('L'))  # ligand

# %% ../nbs/05_gnina_AF3_rescore.ipynb 8
def pdb2sdf(pdb_path, sdf_path):
    "Convert ligand pdb to sdf file"
    mol = Chem.MolFromPDBFile(pdb_path, sanitize=True, removeHs=False)
    if mol:
        writer = Chem.SDWriter(sdf_path)
        writer.write(mol)
        writer.close()
        return None
    else:
        print('Conversion failed for:', pdb_path)
        return pdb_path

# %% ../nbs/05_gnina_AF3_rescore.ipynb 9
def prepare_rec_lig(cif_path, chainA_pdb_path, chainL_sdf_path):
    "Split AF3 cif to protein.pdb (chainA) and ligand.sdf (chainL) "
    
    tmp_name = Path(cif_path).stem
    tmp_path = f'{tmp_name}_lig.pdb'
    split_cif(cif_path, chainA_pdb_path, tmp_path)
    failed = pdb2sdf(tmp_path, chainL_sdf_path)
    try:
        os.remove(tmp_path)
    except OSError:
        pass
    return failed

# %% ../nbs/05_gnina_AF3_rescore.ipynb 14
def gnina_rescore_local(protein_pdb, # receptor file
                  ligand_sdf, # ligand file
                  ):
    
    command = ['./gnina', 
               '-r', protein_pdb, 
               '-l', ligand_sdf, 
               '--minimize']

    result = subprocess.run(command, capture_output=True, text=True)
    return result.stdout

# %% ../nbs/05_gnina_AF3_rescore.ipynb 16
def gnina_rescore_docker(protein_pdb, ligand_sdf):
    """
    Run GNINA rescoring using Docker. Supports receptor and ligand in different folders.
    """
    protein_pdb = Path(protein_pdb).resolve()
    ligand_sdf = Path(ligand_sdf).resolve()

    # Mount points inside the Docker container
    rec_mount = '/recdata'
    lig_mount = '/ligdata'

    command = [
        'docker', 'run', '--rm',
        '-v', f'{protein_pdb.parent}:{rec_mount}', # mount path separately
        '-v', f'{ligand_sdf.parent}:{lig_mount}',
        'gnina/gnina',
        'gnina',
        '-r', f'{rec_mount}/{protein_pdb.name}',
        '-l', f'{lig_mount}/{ligand_sdf.name}',
        '--minimize',
    ]

    result = subprocess.run(command, capture_output=True, text=True)
    return result.stdout

# %% ../nbs/05_gnina_AF3_rescore.ipynb 18
def extract_gnina_rescore(txt):
    "Extract GNINA output text to dictionary."
    
    pattern = re.search(
        r"Affinity:\s+(?P<binding_energy>[-.\d]+)\s+(?P<uncertainty>[-.\d]+).*?"
        r"RMSD:\s+(?P<RMSD>[-.\d]+).*?"
        r"CNNscore:\s+(?P<CNNscore>[-.\d]+).*?"
        r"CNNaffinity:\s+(?P<CNNaffinity>[-.\d]+).*?"
        r"CNNvariance:\s+(?P<CNNvariance>[-.\d]+)",
        txt,
        re.DOTALL)

    if not pattern:
        print("Failed to match GNINA output format.")
    
    return {k: float(v) for k, v in pattern.groupdict().items()} # convert values to float

# %% ../nbs/05_gnina_AF3_rescore.ipynb 21
def get_gnina_rescore(cif_path,is_local=False):
    "Split the CIF into receptor and ligand folders, then extract the GNINA rescored affinity score"
    cif_path = Path(cif_path).expanduser()
    parent,stem = cif_path.parent,cif_path.stem

    rec_dir,lig_dir = Path(str(parent) + '_receptor'),Path(str(parent) + '_ligand')
    
    rec_path,lig_path = rec_dir/f'{stem}.pdb',lig_dir/f'{stem}.sdf'
    
    rec_dir.mkdir(exist_ok=True)
    lig_dir.mkdir(exist_ok=True)
    
    prepare_rec_lig(cif_path,rec_path,lig_path)
    if is_local:
        gnina_output = gnina_rescore_local(rec_path,lig_path)
    else:
        gnina_output = gnina_rescore_docker(rec_path,lig_path)
    return extract_gnina_rescore(gnina_output)

# %% ../nbs/05_gnina_AF3_rescore.ipynb 25
def get_gnina_rescore_folder(cif_folder,is_local=False):
    "Parallel processing to get gnina rescore given folder path"
    cifs = L(Path(cif_folder).expanduser().glob("*.cif")) # just take cif file
    
    func = partial(get_gnina_rescore,is_local=is_local)
    results = process_map(func, cifs, max_workers=4)

    # use path.stem as df index
    results_dict = dict(zip([p.stem for p in cifs], results))
    return pd.DataFrame(results_dict).T.reset_index(names='ID')
