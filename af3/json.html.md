# Generate json


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Single protein sequence (default)

> Default pipeline, will run MSA and template search

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L19"
target="_blank" style="float:right; font-size:smaller">source</a>

### dump_json

>  dump_json (data, save_path)

*Save json data into a file*

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L25"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_protein_json

>  get_protein_json (name, seq, save_path=None, seeds=[1])

*Generate json of single protein sequence for input of docker command*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td></td>
<td></td>
<td>job name</td>
</tr>
<tr>
<td>seq</td>
<td></td>
<td></td>
<td>aa sequence</td>
</tr>
<tr>
<td>save_path</td>
<td>NoneType</td>
<td>None</td>
<td>.json</td>
</tr>
<tr>
<td>seeds</td>
<td>list</td>
<td>[1]</td>
<td></td>
</tr>
</tbody>
</table>

``` python
data = get_protein_json('proteinA','AAA','data/proteinA.json',seeds=[1,2,3])
data
```

    {'name': 'proteinA',
     'modelSeeds': [1, 2, 3],
     'sequences': [{'protein': {'id': 'A', 'sequence': 'AAA'}}],
     'bondedAtomPairs': [],
     'dialect': 'alphafold3',
     'version': 2}

## Protein-SMILES

- First run the normal `sequence only` pipeline for the protein
- Get the output data.json file, read it, load the
  `["sequences"][0]["protein"]`

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L53"
target="_blank" style="float:right; font-size:smaller">source</a>

### read_json

>  read_json (file_path)

``` python
protein_json = read_json('data/seq_only_data.json')
```

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L59"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_protein_smiles_json

>  get_protein_smiles_json (smi_id:str, SMILES:str, protein_json,
>                               save_path=None, seeds=[1])

*Get json for protein-ligand docking task*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>smi_id</td>
<td>str</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SMILES</td>
<td>str</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protein_json</td>
<td></td>
<td></td>
<td>json type</td>
</tr>
<tr>
<td>save_path</td>
<td>NoneType</td>
<td>None</td>
<td>.json</td>
</tr>
<tr>
<td>seeds</td>
<td>list</td>
<td>[1]</td>
<td></td>
</tr>
</tbody>
</table>

``` python
out = get_protein_smiles_json('smi_name','CCC',protein_json,'data/protein_smi.json',seeds=[1,2,3])
```

Let’s take a look for the json:

``` python
str(out)[:100]
```

    "{'name': 'smi_name', 'modelSeeds': [1, 2, 3], 'sequences': [{'ligand': {'id': 'L', 'smiles': 'CCC'}}"

``` python
df = pd.DataFrame({'idx':['a','b'],'smi':['CCC','OCO']})
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">idx</th>
<th data-quarto-table-cell-role="th">smi</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>a</td>
<td>CCC</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>b</td>
<td>OCO</td>
</tr>
</tbody>
</table>

</div>

``` python
project_name='sdf'
for idx, smi in df.values:
    _ = get_protein_smiles_json(idx,smi,protein_json,f'af_input/{project_name}/{idx}.json',seeds=[1,2,3])
```

## Protein-CCDcode

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L93"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_protein_ccdcode_json

>  get_protein_ccdcode_json (protein_json, ccd_code, job_id:str,
>                                save_path=None, seeds=[1])

*Create AlphaFold3 docking JSON with CCD code(s).*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>protein_json</td>
<td></td>
<td></td>
<td>dict with protein sequence</td>
</tr>
<tr>
<td>ccd_code</td>
<td></td>
<td></td>
<td>str or list of str</td>
</tr>
<tr>
<td>job_id</td>
<td>str</td>
<td></td>
<td>job/task ID</td>
</tr>
<tr>
<td>save_path</td>
<td>NoneType</td>
<td>None</td>
<td>optional output path</td>
</tr>
<tr>
<td>seeds</td>
<td>list</td>
<td>[1]</td>
<td>optional random seeds</td>
</tr>
</tbody>
</table>

## Protein-CCD for covalent

### sdf2CCD

`mol_to_ccd_cif` Reference:
https://github.com/google-deepmind/alphafold3/issues/178

About hydrogens:
https://github.com/google-deepmind/alphafold3/issues/212

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L146"
target="_blank" style="float:right; font-size:smaller">source</a>

### mol_to_ccd_text

>  mol_to_ccd_text (mol, component_id, pdbx_smiles=None,
>                       include_hydrogens=False)

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L141"
target="_blank" style="float:right; font-size:smaller">source</a>

### assign_atom_names_from_graph

>  assign_atom_names_from_graph (mol)

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L213"
target="_blank" style="float:right; font-size:smaller">source</a>

### sdf2ccd

>  sdf2ccd (sdf_path, CCD_name='lig-1')

*Convert the compound to the AF3 required CCD format*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sdf_path</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CCD_name</td>
<td>str</td>
<td>lig-1</td>
<td>do not use ’_‘; use as less letter as possible, ’lig-any’ leads to
extra ligands</td>
</tr>
</tbody>
</table>

``` python
sdf2ccd('covalent_test/lig-HKI.sdf')[:100]
```

    "data_lig-any\n#\n_chem_comp.id lig-any\n_chem_comp.name 'lig-any'\n_chem_comp.type non-polymer\n_chem_com"

### json

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L223"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_protein_ccd_json

>  get_protein_ccd_json (protein_json, rec_residue_num:int, rec_atom_id:str,
>                            lig_sdf_path, lig_atom_id:str, job_id:str,
>                            save_path=None, seeds=[1])

*Create AlphaFold3 docking JSON with customized CCD ligand and
bondedAtomPairs.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>protein_json</td>
<td></td>
<td></td>
<td>dict with protein sequence</td>
</tr>
<tr>
<td>rec_residue_num</td>
<td>int</td>
<td></td>
<td>1-indexed, for bondedAtomPairs, e.g., [“A”, 145, “SG”]</td>
</tr>
<tr>
<td>rec_atom_id</td>
<td>str</td>
<td></td>
<td>for bondedAtomPairs, e.g., [“A”, 145, “SG”]</td>
</tr>
<tr>
<td>lig_sdf_path</td>
<td></td>
<td></td>
<td>ccd text</td>
</tr>
<tr>
<td>lig_atom_id</td>
<td>str</td>
<td></td>
<td>0-indexed, for bondedAtomPairs, [“L”, 1, “C04”]</td>
</tr>
<tr>
<td>job_id</td>
<td>str</td>
<td></td>
<td>str, job/task ID</td>
</tr>
<tr>
<td>save_path</td>
<td>NoneType</td>
<td>None</td>
<td>optional output path</td>
</tr>
<tr>
<td>seeds</td>
<td>list</td>
<td>[1]</td>
<td>optional random seeds</td>
</tr>
</tbody>
</table>

Version 2, with user ccd and pair as input:

``` python
def get_protein_ccd_json2(protein_json,             # dict with protein sequence
                         userCCD,                  # ccd text
                         pair1,                    # protein pair e.g., ["A", 145, "SG"] 1-indexed
                         pair2,                    # ligand pair e.g., ["L", 1, "C04"] 0-indexed
                         job_id,                   # str, job/task ID
                         save_path=None,           # optional output path
                         seeds=[1]):               # optional random seeds
    "Create AlphaFold3 docking JSON with customized CCD ligand and bondedAtomPairs."
    
    ccd_id = re.search(r"_chem_comp.id\s+([^\s#]+)", ccd_text).group(1)
    json_data = {
        "name": job_id,
        "modelSeeds": seeds,
        "sequences": [
            {
                "ligand": {
                    "id": "L",
                    "ccdCodes": [ccd_id]
                }
            },
            {
                "protein": protein_json["sequences"][0]["protein"]
            },
        ],
        "bondedAtomPairs": [[pair1,pair2]],
        "userCCD": userCCD,
        "dialect": "alphafold3",
        "version": 3
    }

    if save_path:
        Path(save_path).parent.mkdir(parents=True, exist_ok=True)
        dump_json(json_data, save_path)

    return json_data
```

## Split the files to subfolder

> for multi-GPUs

------------------------------------------------------------------------

<a
href="https://github.com/sky1ove/kdock/blob/main/kdock/af3/json.py#L267"
target="_blank" style="float:right; font-size:smaller">source</a>

### split_nfolder

>  split_nfolder (folder_dir, n=4)

*Move json files from a folder into subfolders (folder_0, folder_1, …,
folder_N).*

``` python
split_nfolder(f'af_input/{project_name}')
```

    Distributed 2 files into 4 folders.

## End

### Reference:

``` python
# import collections
# from collections.abc import Mapping, Sequence

# from absl import logging
# from alphafold3.cpp import cif_dict
# import numpy as np
# import rdkit.Chem as rd_chem
# from rdkit.Chem import AllChem as rd_all_chem

# def mol_to_ccd_cif(
#     mol: rd_chem.Mol,
#     component_id: str,
#     pdbx_smiles: str | None = None,
#     include_hydrogens: bool = True,
# ) -> cif_dict.CifDict:
#   """Creates a CCD-like mmcif data block from an rdkit Mol object.

#   Only a subset of associated mmcif fields is populated, but that is
#   sufficient for further usage, e.g. in featurization code.

#   Atom names can be specified via `atom_name` property. For atoms with
#   unspecified value of that property, the name is assigned based on element type
#   and the order in the Mol object.

#   If the Mol object has associated conformers, atom positions from the first of
#   them will be populated in the resulting mmcif file.

#   Args:
#      mol: An rdkit molecule.
#      component_id: Name of the molecule to use in the resulting mmcif. That is
#        equivalent to CCD code.
#      pdbx_smiles: If specified, the value will be used to populate
#        `_chem_comp.pdbx_smiles`.
#      include_hydrogens: Whether to include atom and bond data involving
#        hydrogens.

#   Returns:
#      An mmcif data block corresponding for the given rdkit molecule.

#   Raises:
#     UnsupportedMolBond: When a molecule contains a bond that can't be
#       represented with mmcif.
#   """
#   mol = rd_chem.Mol(mol)
#   if include_hydrogens:
#     mol = rd_chem.AddHs(mol)
#   rd_chem.Kekulize(mol)

#   if mol.GetNumConformers() > 0:
#     ideal_conformer = mol.GetConformer(0).GetPositions()
#     ideal_conformer = np.vectorize(lambda x: f'{x:.3f}')(ideal_conformer)
#   else:
#     # No data will be populated in the resulting mmcif if the molecule doesn't
#     # have any conformers attached to it.
#     ideal_conformer = None

#   mol_cif = collections.defaultdict(list)
#   mol_cif['data_'] = [component_id]
#   mol_cif['_chem_comp.id'] = [component_id]
#   if pdbx_smiles:
#     mol_cif['_chem_comp.pdbx_smiles'] = [pdbx_smiles]

#   mol = assign_atom_names_from_graph(mol, keep_existing_names=True)

#   for atom_idx, atom in enumerate(mol.GetAtoms()):
#     element = atom.GetSymbol()
#     if not include_hydrogens and element in ('H', 'D'):
#       continue

#     mol_cif['_chem_comp_atom.comp_id'].append(component_id)
#     mol_cif['_chem_comp_atom.atom_id'].append(atom.GetProp('atom_name'))
#     mol_cif['_chem_comp_atom.type_symbol'].append(atom.GetSymbol().upper())
#     mol_cif['_chem_comp_atom.charge'].append(str(atom.GetFormalCharge()))
#     if ideal_conformer is not None:
#       coords = ideal_conformer[atom_idx]
#       mol_cif['_chem_comp_atom.pdbx_model_Cartn_x_ideal'].append(coords[0])
#       mol_cif['_chem_comp_atom.pdbx_model_Cartn_y_ideal'].append(coords[1])
#       mol_cif['_chem_comp_atom.pdbx_model_Cartn_z_ideal'].append(coords[2])

#   for bond in mol.GetBonds():
#     atom1 = bond.GetBeginAtom()
#     atom2 = bond.GetEndAtom()
#     if not include_hydrogens and (
#         atom1.GetSymbol() in ('H', 'D') or atom2.GetSymbol() in ('H', 'D')
#     ):
#       continue
#     mol_cif['_chem_comp_bond.comp_id'].append(component_id)
#     mol_cif['_chem_comp_bond.atom_id_1'].append(
#         bond.GetBeginAtom().GetProp('atom_name')
#     )
#     mol_cif['_chem_comp_bond.atom_id_2'].append(
#         bond.GetEndAtom().GetProp('atom_name')
#     )
#     try:
#       bond_type = bond.GetBondType()
#       # Older versions of RDKit did not have a DATIVE bond type. Convert it to
#       # SINGLE to match the AF3 training setup.
#       if bond_type == rd_chem.BondType.DATIVE:
#         bond_type = rd_chem.BondType.SINGLE
#       mol_cif['_chem_comp_bond.value_order'].append(
#           _RDKIT_BOND_TYPE_TO_MMCIF[bond_type]
#       )
#       mol_cif['_chem_comp_bond.pdbx_stereo_config'].append(
#           _RDKIT_BOND_STEREO_TO_MMCIF[bond.GetStereo()]
#       )
#     except KeyError as e:
#       raise UnsupportedMolBondError from e
#     mol_cif['_chem_comp_bond.pdbx_aromatic_flag'].append(
#         'Y' if bond.GetIsAromatic() else 'N'
#     )

#   return cif_dict.CifDict(mol_cif)
```
